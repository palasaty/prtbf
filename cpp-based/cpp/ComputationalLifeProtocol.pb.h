// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ComputationalLifeProtocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ComputationalLifeProtocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ComputationalLifeProtocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ComputationalLifeProtocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ComputationalLifeProtocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ComputationalLifeProtocol_2eproto;
class BoundaryConditionData;
class BoundaryConditionDataDefaultTypeInternal;
extern BoundaryConditionDataDefaultTypeInternal _BoundaryConditionData_default_instance_;
class BoundaryConditionsData;
class BoundaryConditionsDataDefaultTypeInternal;
extern BoundaryConditionsDataDefaultTypeInternal _BoundaryConditionsData_default_instance_;
class BoundaryConditionsListData;
class BoundaryConditionsListDataDefaultTypeInternal;
extern BoundaryConditionsListDataDefaultTypeInternal _BoundaryConditionsListData_default_instance_;
class ConcentrationConditionData;
class ConcentrationConditionDataDefaultTypeInternal;
extern ConcentrationConditionDataDefaultTypeInternal _ConcentrationConditionData_default_instance_;
class FlowConditionData;
class FlowConditionDataDefaultTypeInternal;
extern FlowConditionDataDefaultTypeInternal _FlowConditionData_default_instance_;
class MarchData;
class MarchDataDefaultTypeInternal;
extern MarchDataDefaultTypeInternal _MarchData_default_instance_;
class ModelInterchangeData;
class ModelInterchangeDataDefaultTypeInternal;
extern ModelInterchangeDataDefaultTypeInternal _ModelInterchangeData_default_instance_;
class PressureConditionData;
class PressureConditionDataDefaultTypeInternal;
extern PressureConditionDataDefaultTypeInternal _PressureConditionData_default_instance_;
class StopData;
class StopDataDefaultTypeInternal;
extern StopDataDefaultTypeInternal _StopData_default_instance_;
class SubstanceData;
class SubstanceDataDefaultTypeInternal;
extern SubstanceDataDefaultTypeInternal _SubstanceData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BoundaryConditionData* Arena::CreateMaybeMessage<::BoundaryConditionData>(Arena*);
template<> ::BoundaryConditionsData* Arena::CreateMaybeMessage<::BoundaryConditionsData>(Arena*);
template<> ::BoundaryConditionsListData* Arena::CreateMaybeMessage<::BoundaryConditionsListData>(Arena*);
template<> ::ConcentrationConditionData* Arena::CreateMaybeMessage<::ConcentrationConditionData>(Arena*);
template<> ::FlowConditionData* Arena::CreateMaybeMessage<::FlowConditionData>(Arena*);
template<> ::MarchData* Arena::CreateMaybeMessage<::MarchData>(Arena*);
template<> ::ModelInterchangeData* Arena::CreateMaybeMessage<::ModelInterchangeData>(Arena*);
template<> ::PressureConditionData* Arena::CreateMaybeMessage<::PressureConditionData>(Arena*);
template<> ::StopData* Arena::CreateMaybeMessage<::StopData>(Arena*);
template<> ::SubstanceData* Arena::CreateMaybeMessage<::SubstanceData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ePropertyType : int {
  Providing = 0,
  Requested = 1,
  ePropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ePropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ePropertyType_IsValid(int value);
constexpr ePropertyType ePropertyType_MIN = Providing;
constexpr ePropertyType ePropertyType_MAX = Requested;
constexpr int ePropertyType_ARRAYSIZE = ePropertyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ePropertyType_descriptor();
template<typename T>
inline const std::string& ePropertyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ePropertyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ePropertyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ePropertyType_descriptor(), enum_t_value);
}
inline bool ePropertyType_Parse(
    const std::string& name, ePropertyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ePropertyType>(
    ePropertyType_descriptor(), name, value);
}
// ===================================================================

class FlowConditionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FlowConditionData) */ {
 public:
  FlowConditionData();
  virtual ~FlowConditionData();

  FlowConditionData(const FlowConditionData& from);
  FlowConditionData(FlowConditionData&& from) noexcept
    : FlowConditionData() {
    *this = ::std::move(from);
  }

  inline FlowConditionData& operator=(const FlowConditionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowConditionData& operator=(FlowConditionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlowConditionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowConditionData* internal_default_instance() {
    return reinterpret_cast<const FlowConditionData*>(
               &_FlowConditionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FlowConditionData& a, FlowConditionData& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowConditionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowConditionData* New() const final {
    return CreateMaybeMessage<FlowConditionData>(nullptr);
  }

  FlowConditionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowConditionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlowConditionData& from);
  void MergeFrom(const FlowConditionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowConditionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FlowConditionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMLPerSFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // double mL_per_s = 2;
  void clear_ml_per_s();
  double ml_per_s() const;
  void set_ml_per_s(double value);

  // .ePropertyType Type = 1;
  void clear_type();
  ::ePropertyType type() const;
  void set_type(::ePropertyType value);

  // @@protoc_insertion_point(class_scope:FlowConditionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double ml_per_s_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class PressureConditionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PressureConditionData) */ {
 public:
  PressureConditionData();
  virtual ~PressureConditionData();

  PressureConditionData(const PressureConditionData& from);
  PressureConditionData(PressureConditionData&& from) noexcept
    : PressureConditionData() {
    *this = ::std::move(from);
  }

  inline PressureConditionData& operator=(const PressureConditionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PressureConditionData& operator=(PressureConditionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PressureConditionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PressureConditionData* internal_default_instance() {
    return reinterpret_cast<const PressureConditionData*>(
               &_PressureConditionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PressureConditionData& a, PressureConditionData& b) {
    a.Swap(&b);
  }
  inline void Swap(PressureConditionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PressureConditionData* New() const final {
    return CreateMaybeMessage<PressureConditionData>(nullptr);
  }

  PressureConditionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PressureConditionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PressureConditionData& from);
  void MergeFrom(const PressureConditionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PressureConditionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PressureConditionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMmHgFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // double mmHg = 2;
  void clear_mmhg();
  double mmhg() const;
  void set_mmhg(double value);

  // .ePropertyType Type = 1;
  void clear_type();
  ::ePropertyType type() const;
  void set_type(::ePropertyType value);

  // @@protoc_insertion_point(class_scope:PressureConditionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double mmhg_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class ConcentrationConditionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConcentrationConditionData) */ {
 public:
  ConcentrationConditionData();
  virtual ~ConcentrationConditionData();

  ConcentrationConditionData(const ConcentrationConditionData& from);
  ConcentrationConditionData(ConcentrationConditionData&& from) noexcept
    : ConcentrationConditionData() {
    *this = ::std::move(from);
  }

  inline ConcentrationConditionData& operator=(const ConcentrationConditionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConcentrationConditionData& operator=(ConcentrationConditionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConcentrationConditionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConcentrationConditionData* internal_default_instance() {
    return reinterpret_cast<const ConcentrationConditionData*>(
               &_ConcentrationConditionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConcentrationConditionData& a, ConcentrationConditionData& b) {
    a.Swap(&b);
  }
  inline void Swap(ConcentrationConditionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConcentrationConditionData* New() const final {
    return CreateMaybeMessage<ConcentrationConditionData>(nullptr);
  }

  ConcentrationConditionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConcentrationConditionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConcentrationConditionData& from);
  void MergeFrom(const ConcentrationConditionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConcentrationConditionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConcentrationConditionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMgPerMLFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // double mg_per_mL = 2;
  void clear_mg_per_ml();
  double mg_per_ml() const;
  void set_mg_per_ml(double value);

  // .ePropertyType Type = 1;
  void clear_type();
  ::ePropertyType type() const;
  void set_type(::ePropertyType value);

  // @@protoc_insertion_point(class_scope:ConcentrationConditionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double mg_per_ml_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class SubstanceData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SubstanceData) */ {
 public:
  SubstanceData();
  virtual ~SubstanceData();

  SubstanceData(const SubstanceData& from);
  SubstanceData(SubstanceData&& from) noexcept
    : SubstanceData() {
    *this = ::std::move(from);
  }

  inline SubstanceData& operator=(const SubstanceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubstanceData& operator=(SubstanceData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubstanceData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubstanceData* internal_default_instance() {
    return reinterpret_cast<const SubstanceData*>(
               &_SubstanceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubstanceData& a, SubstanceData& b) {
    a.Swap(&b);
  }
  inline void Swap(SubstanceData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubstanceData* New() const final {
    return CreateMaybeMessage<SubstanceData>(nullptr);
  }

  SubstanceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubstanceData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubstanceData& from);
  void MergeFrom(const SubstanceData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubstanceData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubstanceData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kConcentrationFieldNumber = 2,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .ConcentrationConditionData Concentration = 2;
  bool has_concentration() const;
  void clear_concentration();
  const ::ConcentrationConditionData& concentration() const;
  ::ConcentrationConditionData* release_concentration();
  ::ConcentrationConditionData* mutable_concentration();
  void set_allocated_concentration(::ConcentrationConditionData* concentration);

  // @@protoc_insertion_point(class_scope:SubstanceData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::ConcentrationConditionData* concentration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class BoundaryConditionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BoundaryConditionData) */ {
 public:
  BoundaryConditionData();
  virtual ~BoundaryConditionData();

  BoundaryConditionData(const BoundaryConditionData& from);
  BoundaryConditionData(BoundaryConditionData&& from) noexcept
    : BoundaryConditionData() {
    *this = ::std::move(from);
  }

  inline BoundaryConditionData& operator=(const BoundaryConditionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundaryConditionData& operator=(BoundaryConditionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundaryConditionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundaryConditionData* internal_default_instance() {
    return reinterpret_cast<const BoundaryConditionData*>(
               &_BoundaryConditionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BoundaryConditionData& a, BoundaryConditionData& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundaryConditionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundaryConditionData* New() const final {
    return CreateMaybeMessage<BoundaryConditionData>(nullptr);
  }

  BoundaryConditionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundaryConditionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundaryConditionData& from);
  void MergeFrom(const BoundaryConditionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundaryConditionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BoundaryConditionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubstanceFieldNumber = 5,
    kNameFieldNumber = 2,
    kFlowFieldNumber = 3,
    kPressureFieldNumber = 4,
    kIDFieldNumber = 1,
  };
  // repeated .SubstanceData Substance = 5;
  int substance_size() const;
  void clear_substance();
  ::SubstanceData* mutable_substance(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubstanceData >*
      mutable_substance();
  const ::SubstanceData& substance(int index) const;
  ::SubstanceData* add_substance();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubstanceData >&
      substance() const;

  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .FlowConditionData Flow = 3;
  bool has_flow() const;
  void clear_flow();
  const ::FlowConditionData& flow() const;
  ::FlowConditionData* release_flow();
  ::FlowConditionData* mutable_flow();
  void set_allocated_flow(::FlowConditionData* flow);

  // .PressureConditionData Pressure = 4;
  bool has_pressure() const;
  void clear_pressure();
  const ::PressureConditionData& pressure() const;
  ::PressureConditionData* release_pressure();
  ::PressureConditionData* mutable_pressure();
  void set_allocated_pressure(::PressureConditionData* pressure);

  // int32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:BoundaryConditionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubstanceData > substance_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::FlowConditionData* flow_;
  ::PressureConditionData* pressure_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class BoundaryConditionsData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BoundaryConditionsData) */ {
 public:
  BoundaryConditionsData();
  virtual ~BoundaryConditionsData();

  BoundaryConditionsData(const BoundaryConditionsData& from);
  BoundaryConditionsData(BoundaryConditionsData&& from) noexcept
    : BoundaryConditionsData() {
    *this = ::std::move(from);
  }

  inline BoundaryConditionsData& operator=(const BoundaryConditionsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundaryConditionsData& operator=(BoundaryConditionsData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundaryConditionsData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundaryConditionsData* internal_default_instance() {
    return reinterpret_cast<const BoundaryConditionsData*>(
               &_BoundaryConditionsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BoundaryConditionsData& a, BoundaryConditionsData& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundaryConditionsData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundaryConditionsData* New() const final {
    return CreateMaybeMessage<BoundaryConditionsData>(nullptr);
  }

  BoundaryConditionsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundaryConditionsData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundaryConditionsData& from);
  void MergeFrom(const BoundaryConditionsData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundaryConditionsData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BoundaryConditionsData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInletFieldNumber = 1,
    kOutletFieldNumber = 2,
  };
  // .BoundaryConditionData Inlet = 1;
  bool has_inlet() const;
  void clear_inlet();
  const ::BoundaryConditionData& inlet() const;
  ::BoundaryConditionData* release_inlet();
  ::BoundaryConditionData* mutable_inlet();
  void set_allocated_inlet(::BoundaryConditionData* inlet);

  // .BoundaryConditionData Outlet = 2;
  bool has_outlet() const;
  void clear_outlet();
  const ::BoundaryConditionData& outlet() const;
  ::BoundaryConditionData* release_outlet();
  ::BoundaryConditionData* mutable_outlet();
  void set_allocated_outlet(::BoundaryConditionData* outlet);

  // @@protoc_insertion_point(class_scope:BoundaryConditionsData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::BoundaryConditionData* inlet_;
  ::BoundaryConditionData* outlet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class BoundaryConditionsListData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BoundaryConditionsListData) */ {
 public:
  BoundaryConditionsListData();
  virtual ~BoundaryConditionsListData();

  BoundaryConditionsListData(const BoundaryConditionsListData& from);
  BoundaryConditionsListData(BoundaryConditionsListData&& from) noexcept
    : BoundaryConditionsListData() {
    *this = ::std::move(from);
  }

  inline BoundaryConditionsListData& operator=(const BoundaryConditionsListData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundaryConditionsListData& operator=(BoundaryConditionsListData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundaryConditionsListData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundaryConditionsListData* internal_default_instance() {
    return reinterpret_cast<const BoundaryConditionsListData*>(
               &_BoundaryConditionsListData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BoundaryConditionsListData& a, BoundaryConditionsListData& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundaryConditionsListData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundaryConditionsListData* New() const final {
    return CreateMaybeMessage<BoundaryConditionsListData>(nullptr);
  }

  BoundaryConditionsListData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundaryConditionsListData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundaryConditionsListData& from);
  void MergeFrom(const BoundaryConditionsListData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundaryConditionsListData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BoundaryConditionsListData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundaryConditionsFieldNumber = 1,
  };
  // repeated .BoundaryConditionsData BoundaryConditions = 1;
  int boundaryconditions_size() const;
  void clear_boundaryconditions();
  ::BoundaryConditionsData* mutable_boundaryconditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BoundaryConditionsData >*
      mutable_boundaryconditions();
  const ::BoundaryConditionsData& boundaryconditions(int index) const;
  ::BoundaryConditionsData* add_boundaryconditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BoundaryConditionsData >&
      boundaryconditions() const;

  // @@protoc_insertion_point(class_scope:BoundaryConditionsListData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BoundaryConditionsData > boundaryconditions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class MarchData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MarchData) */ {
 public:
  MarchData();
  virtual ~MarchData();

  MarchData(const MarchData& from);
  MarchData(MarchData&& from) noexcept
    : MarchData() {
    *this = ::std::move(from);
  }

  inline MarchData& operator=(const MarchData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarchData& operator=(MarchData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MarchData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarchData* internal_default_instance() {
    return reinterpret_cast<const MarchData*>(
               &_MarchData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MarchData& a, MarchData& b) {
    a.Swap(&b);
  }
  inline void Swap(MarchData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MarchData* New() const final {
    return CreateMaybeMessage<MarchData>(nullptr);
  }

  MarchData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MarchData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MarchData& from);
  void MergeFrom(const MarchData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarchData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MarchData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationSFieldNumber = 1,
  };
  // double Duration_s = 1;
  void clear_duration_s();
  double duration_s() const;
  void set_duration_s(double value);

  // @@protoc_insertion_point(class_scope:MarchData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double duration_s_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class StopData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StopData) */ {
 public:
  StopData();
  virtual ~StopData();

  StopData(const StopData& from);
  StopData(StopData&& from) noexcept
    : StopData() {
    *this = ::std::move(from);
  }

  inline StopData& operator=(const StopData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopData& operator=(StopData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopData* internal_default_instance() {
    return reinterpret_cast<const StopData*>(
               &_StopData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StopData& a, StopData& b) {
    a.Swap(&b);
  }
  inline void Swap(StopData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopData* New() const final {
    return CreateMaybeMessage<StopData>(nullptr);
  }

  StopData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopData& from);
  void MergeFrom(const StopData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StopData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:StopData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// -------------------------------------------------------------------

class ModelInterchangeData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModelInterchangeData) */ {
 public:
  ModelInterchangeData();
  virtual ~ModelInterchangeData();

  ModelInterchangeData(const ModelInterchangeData& from);
  ModelInterchangeData(ModelInterchangeData&& from) noexcept
    : ModelInterchangeData() {
    *this = ::std::move(from);
  }

  inline ModelInterchangeData& operator=(const ModelInterchangeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInterchangeData& operator=(ModelInterchangeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInterchangeData& default_instance();

  enum CommandCase {
    kBoundaryExchangeList = 1,
    kMarch = 2,
    kStop = 3,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInterchangeData* internal_default_instance() {
    return reinterpret_cast<const ModelInterchangeData*>(
               &_ModelInterchangeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModelInterchangeData& a, ModelInterchangeData& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInterchangeData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInterchangeData* New() const final {
    return CreateMaybeMessage<ModelInterchangeData>(nullptr);
  }

  ModelInterchangeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInterchangeData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInterchangeData& from);
  void MergeFrom(const ModelInterchangeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInterchangeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModelInterchangeData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ComputationalLifeProtocol_2eproto);
    return ::descriptor_table_ComputationalLifeProtocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundaryExchangeListFieldNumber = 1,
    kMarchFieldNumber = 2,
    kStopFieldNumber = 3,
  };
  // .BoundaryConditionsListData BoundaryExchangeList = 1;
  bool has_boundaryexchangelist() const;
  void clear_boundaryexchangelist();
  const ::BoundaryConditionsListData& boundaryexchangelist() const;
  ::BoundaryConditionsListData* release_boundaryexchangelist();
  ::BoundaryConditionsListData* mutable_boundaryexchangelist();
  void set_allocated_boundaryexchangelist(::BoundaryConditionsListData* boundaryexchangelist);

  // .MarchData March = 2;
  bool has_march() const;
  void clear_march();
  const ::MarchData& march() const;
  ::MarchData* release_march();
  ::MarchData* mutable_march();
  void set_allocated_march(::MarchData* march);

  // .StopData Stop = 3;
  bool has_stop() const;
  void clear_stop();
  const ::StopData& stop() const;
  ::StopData* release_stop();
  ::StopData* mutable_stop();
  void set_allocated_stop(::StopData* stop);

  void clear_Command();
  CommandCase Command_case() const;
  // @@protoc_insertion_point(class_scope:ModelInterchangeData)
 private:
  class _Internal;
  void set_has_boundaryexchangelist();
  void set_has_march();
  void set_has_stop();

  inline bool has_Command() const;
  inline void clear_has_Command();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union CommandUnion {
    CommandUnion() {}
    ::BoundaryConditionsListData* boundaryexchangelist_;
    ::MarchData* march_;
    ::StopData* stop_;
  } Command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ComputationalLifeProtocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FlowConditionData

// .ePropertyType Type = 1;
inline void FlowConditionData::clear_type() {
  type_ = 0;
}
inline ::ePropertyType FlowConditionData::type() const {
  // @@protoc_insertion_point(field_get:FlowConditionData.Type)
  return static_cast< ::ePropertyType >(type_);
}
inline void FlowConditionData::set_type(::ePropertyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:FlowConditionData.Type)
}

// double mL_per_s = 2;
inline void FlowConditionData::clear_ml_per_s() {
  ml_per_s_ = 0;
}
inline double FlowConditionData::ml_per_s() const {
  // @@protoc_insertion_point(field_get:FlowConditionData.mL_per_s)
  return ml_per_s_;
}
inline void FlowConditionData::set_ml_per_s(double value) {
  
  ml_per_s_ = value;
  // @@protoc_insertion_point(field_set:FlowConditionData.mL_per_s)
}

// -------------------------------------------------------------------

// PressureConditionData

// .ePropertyType Type = 1;
inline void PressureConditionData::clear_type() {
  type_ = 0;
}
inline ::ePropertyType PressureConditionData::type() const {
  // @@protoc_insertion_point(field_get:PressureConditionData.Type)
  return static_cast< ::ePropertyType >(type_);
}
inline void PressureConditionData::set_type(::ePropertyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PressureConditionData.Type)
}

// double mmHg = 2;
inline void PressureConditionData::clear_mmhg() {
  mmhg_ = 0;
}
inline double PressureConditionData::mmhg() const {
  // @@protoc_insertion_point(field_get:PressureConditionData.mmHg)
  return mmhg_;
}
inline void PressureConditionData::set_mmhg(double value) {
  
  mmhg_ = value;
  // @@protoc_insertion_point(field_set:PressureConditionData.mmHg)
}

// -------------------------------------------------------------------

// ConcentrationConditionData

// .ePropertyType Type = 1;
inline void ConcentrationConditionData::clear_type() {
  type_ = 0;
}
inline ::ePropertyType ConcentrationConditionData::type() const {
  // @@protoc_insertion_point(field_get:ConcentrationConditionData.Type)
  return static_cast< ::ePropertyType >(type_);
}
inline void ConcentrationConditionData::set_type(::ePropertyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ConcentrationConditionData.Type)
}

// double mg_per_mL = 2;
inline void ConcentrationConditionData::clear_mg_per_ml() {
  mg_per_ml_ = 0;
}
inline double ConcentrationConditionData::mg_per_ml() const {
  // @@protoc_insertion_point(field_get:ConcentrationConditionData.mg_per_mL)
  return mg_per_ml_;
}
inline void ConcentrationConditionData::set_mg_per_ml(double value) {
  
  mg_per_ml_ = value;
  // @@protoc_insertion_point(field_set:ConcentrationConditionData.mg_per_mL)
}

// -------------------------------------------------------------------

// SubstanceData

// string Name = 1;
inline void SubstanceData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SubstanceData::name() const {
  // @@protoc_insertion_point(field_get:SubstanceData.Name)
  return name_.GetNoArena();
}
inline void SubstanceData::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubstanceData.Name)
}
inline void SubstanceData::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SubstanceData.Name)
}
inline void SubstanceData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubstanceData.Name)
}
inline void SubstanceData::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubstanceData.Name)
}
inline std::string* SubstanceData::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:SubstanceData.Name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SubstanceData::release_name() {
  // @@protoc_insertion_point(field_release:SubstanceData.Name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SubstanceData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SubstanceData.Name)
}

// .ConcentrationConditionData Concentration = 2;
inline bool SubstanceData::has_concentration() const {
  return this != internal_default_instance() && concentration_ != nullptr;
}
inline void SubstanceData::clear_concentration() {
  if (GetArenaNoVirtual() == nullptr && concentration_ != nullptr) {
    delete concentration_;
  }
  concentration_ = nullptr;
}
inline const ::ConcentrationConditionData& SubstanceData::concentration() const {
  const ::ConcentrationConditionData* p = concentration_;
  // @@protoc_insertion_point(field_get:SubstanceData.Concentration)
  return p != nullptr ? *p : *reinterpret_cast<const ::ConcentrationConditionData*>(
      &::_ConcentrationConditionData_default_instance_);
}
inline ::ConcentrationConditionData* SubstanceData::release_concentration() {
  // @@protoc_insertion_point(field_release:SubstanceData.Concentration)
  
  ::ConcentrationConditionData* temp = concentration_;
  concentration_ = nullptr;
  return temp;
}
inline ::ConcentrationConditionData* SubstanceData::mutable_concentration() {
  
  if (concentration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ConcentrationConditionData>(GetArenaNoVirtual());
    concentration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SubstanceData.Concentration)
  return concentration_;
}
inline void SubstanceData::set_allocated_concentration(::ConcentrationConditionData* concentration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete concentration_;
  }
  if (concentration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      concentration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, concentration, submessage_arena);
    }
    
  } else {
    
  }
  concentration_ = concentration;
  // @@protoc_insertion_point(field_set_allocated:SubstanceData.Concentration)
}

// -------------------------------------------------------------------

// BoundaryConditionData

// int32 ID = 1;
inline void BoundaryConditionData::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoundaryConditionData::id() const {
  // @@protoc_insertion_point(field_get:BoundaryConditionData.ID)
  return id_;
}
inline void BoundaryConditionData::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:BoundaryConditionData.ID)
}

// string Name = 2;
inline void BoundaryConditionData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BoundaryConditionData::name() const {
  // @@protoc_insertion_point(field_get:BoundaryConditionData.Name)
  return name_.GetNoArena();
}
inline void BoundaryConditionData::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BoundaryConditionData.Name)
}
inline void BoundaryConditionData::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BoundaryConditionData.Name)
}
inline void BoundaryConditionData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BoundaryConditionData.Name)
}
inline void BoundaryConditionData::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BoundaryConditionData.Name)
}
inline std::string* BoundaryConditionData::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:BoundaryConditionData.Name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BoundaryConditionData::release_name() {
  // @@protoc_insertion_point(field_release:BoundaryConditionData.Name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BoundaryConditionData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:BoundaryConditionData.Name)
}

// .FlowConditionData Flow = 3;
inline bool BoundaryConditionData::has_flow() const {
  return this != internal_default_instance() && flow_ != nullptr;
}
inline void BoundaryConditionData::clear_flow() {
  if (GetArenaNoVirtual() == nullptr && flow_ != nullptr) {
    delete flow_;
  }
  flow_ = nullptr;
}
inline const ::FlowConditionData& BoundaryConditionData::flow() const {
  const ::FlowConditionData* p = flow_;
  // @@protoc_insertion_point(field_get:BoundaryConditionData.Flow)
  return p != nullptr ? *p : *reinterpret_cast<const ::FlowConditionData*>(
      &::_FlowConditionData_default_instance_);
}
inline ::FlowConditionData* BoundaryConditionData::release_flow() {
  // @@protoc_insertion_point(field_release:BoundaryConditionData.Flow)
  
  ::FlowConditionData* temp = flow_;
  flow_ = nullptr;
  return temp;
}
inline ::FlowConditionData* BoundaryConditionData::mutable_flow() {
  
  if (flow_ == nullptr) {
    auto* p = CreateMaybeMessage<::FlowConditionData>(GetArenaNoVirtual());
    flow_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BoundaryConditionData.Flow)
  return flow_;
}
inline void BoundaryConditionData::set_allocated_flow(::FlowConditionData* flow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete flow_;
  }
  if (flow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow, submessage_arena);
    }
    
  } else {
    
  }
  flow_ = flow;
  // @@protoc_insertion_point(field_set_allocated:BoundaryConditionData.Flow)
}

// .PressureConditionData Pressure = 4;
inline bool BoundaryConditionData::has_pressure() const {
  return this != internal_default_instance() && pressure_ != nullptr;
}
inline void BoundaryConditionData::clear_pressure() {
  if (GetArenaNoVirtual() == nullptr && pressure_ != nullptr) {
    delete pressure_;
  }
  pressure_ = nullptr;
}
inline const ::PressureConditionData& BoundaryConditionData::pressure() const {
  const ::PressureConditionData* p = pressure_;
  // @@protoc_insertion_point(field_get:BoundaryConditionData.Pressure)
  return p != nullptr ? *p : *reinterpret_cast<const ::PressureConditionData*>(
      &::_PressureConditionData_default_instance_);
}
inline ::PressureConditionData* BoundaryConditionData::release_pressure() {
  // @@protoc_insertion_point(field_release:BoundaryConditionData.Pressure)
  
  ::PressureConditionData* temp = pressure_;
  pressure_ = nullptr;
  return temp;
}
inline ::PressureConditionData* BoundaryConditionData::mutable_pressure() {
  
  if (pressure_ == nullptr) {
    auto* p = CreateMaybeMessage<::PressureConditionData>(GetArenaNoVirtual());
    pressure_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BoundaryConditionData.Pressure)
  return pressure_;
}
inline void BoundaryConditionData::set_allocated_pressure(::PressureConditionData* pressure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pressure_;
  }
  if (pressure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pressure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pressure, submessage_arena);
    }
    
  } else {
    
  }
  pressure_ = pressure;
  // @@protoc_insertion_point(field_set_allocated:BoundaryConditionData.Pressure)
}

// repeated .SubstanceData Substance = 5;
inline int BoundaryConditionData::substance_size() const {
  return substance_.size();
}
inline void BoundaryConditionData::clear_substance() {
  substance_.Clear();
}
inline ::SubstanceData* BoundaryConditionData::mutable_substance(int index) {
  // @@protoc_insertion_point(field_mutable:BoundaryConditionData.Substance)
  return substance_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubstanceData >*
BoundaryConditionData::mutable_substance() {
  // @@protoc_insertion_point(field_mutable_list:BoundaryConditionData.Substance)
  return &substance_;
}
inline const ::SubstanceData& BoundaryConditionData::substance(int index) const {
  // @@protoc_insertion_point(field_get:BoundaryConditionData.Substance)
  return substance_.Get(index);
}
inline ::SubstanceData* BoundaryConditionData::add_substance() {
  // @@protoc_insertion_point(field_add:BoundaryConditionData.Substance)
  return substance_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubstanceData >&
BoundaryConditionData::substance() const {
  // @@protoc_insertion_point(field_list:BoundaryConditionData.Substance)
  return substance_;
}

// -------------------------------------------------------------------

// BoundaryConditionsData

// .BoundaryConditionData Inlet = 1;
inline bool BoundaryConditionsData::has_inlet() const {
  return this != internal_default_instance() && inlet_ != nullptr;
}
inline void BoundaryConditionsData::clear_inlet() {
  if (GetArenaNoVirtual() == nullptr && inlet_ != nullptr) {
    delete inlet_;
  }
  inlet_ = nullptr;
}
inline const ::BoundaryConditionData& BoundaryConditionsData::inlet() const {
  const ::BoundaryConditionData* p = inlet_;
  // @@protoc_insertion_point(field_get:BoundaryConditionsData.Inlet)
  return p != nullptr ? *p : *reinterpret_cast<const ::BoundaryConditionData*>(
      &::_BoundaryConditionData_default_instance_);
}
inline ::BoundaryConditionData* BoundaryConditionsData::release_inlet() {
  // @@protoc_insertion_point(field_release:BoundaryConditionsData.Inlet)
  
  ::BoundaryConditionData* temp = inlet_;
  inlet_ = nullptr;
  return temp;
}
inline ::BoundaryConditionData* BoundaryConditionsData::mutable_inlet() {
  
  if (inlet_ == nullptr) {
    auto* p = CreateMaybeMessage<::BoundaryConditionData>(GetArenaNoVirtual());
    inlet_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BoundaryConditionsData.Inlet)
  return inlet_;
}
inline void BoundaryConditionsData::set_allocated_inlet(::BoundaryConditionData* inlet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete inlet_;
  }
  if (inlet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inlet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inlet, submessage_arena);
    }
    
  } else {
    
  }
  inlet_ = inlet;
  // @@protoc_insertion_point(field_set_allocated:BoundaryConditionsData.Inlet)
}

// .BoundaryConditionData Outlet = 2;
inline bool BoundaryConditionsData::has_outlet() const {
  return this != internal_default_instance() && outlet_ != nullptr;
}
inline void BoundaryConditionsData::clear_outlet() {
  if (GetArenaNoVirtual() == nullptr && outlet_ != nullptr) {
    delete outlet_;
  }
  outlet_ = nullptr;
}
inline const ::BoundaryConditionData& BoundaryConditionsData::outlet() const {
  const ::BoundaryConditionData* p = outlet_;
  // @@protoc_insertion_point(field_get:BoundaryConditionsData.Outlet)
  return p != nullptr ? *p : *reinterpret_cast<const ::BoundaryConditionData*>(
      &::_BoundaryConditionData_default_instance_);
}
inline ::BoundaryConditionData* BoundaryConditionsData::release_outlet() {
  // @@protoc_insertion_point(field_release:BoundaryConditionsData.Outlet)
  
  ::BoundaryConditionData* temp = outlet_;
  outlet_ = nullptr;
  return temp;
}
inline ::BoundaryConditionData* BoundaryConditionsData::mutable_outlet() {
  
  if (outlet_ == nullptr) {
    auto* p = CreateMaybeMessage<::BoundaryConditionData>(GetArenaNoVirtual());
    outlet_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BoundaryConditionsData.Outlet)
  return outlet_;
}
inline void BoundaryConditionsData::set_allocated_outlet(::BoundaryConditionData* outlet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete outlet_;
  }
  if (outlet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      outlet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outlet, submessage_arena);
    }
    
  } else {
    
  }
  outlet_ = outlet;
  // @@protoc_insertion_point(field_set_allocated:BoundaryConditionsData.Outlet)
}

// -------------------------------------------------------------------

// BoundaryConditionsListData

// repeated .BoundaryConditionsData BoundaryConditions = 1;
inline int BoundaryConditionsListData::boundaryconditions_size() const {
  return boundaryconditions_.size();
}
inline void BoundaryConditionsListData::clear_boundaryconditions() {
  boundaryconditions_.Clear();
}
inline ::BoundaryConditionsData* BoundaryConditionsListData::mutable_boundaryconditions(int index) {
  // @@protoc_insertion_point(field_mutable:BoundaryConditionsListData.BoundaryConditions)
  return boundaryconditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BoundaryConditionsData >*
BoundaryConditionsListData::mutable_boundaryconditions() {
  // @@protoc_insertion_point(field_mutable_list:BoundaryConditionsListData.BoundaryConditions)
  return &boundaryconditions_;
}
inline const ::BoundaryConditionsData& BoundaryConditionsListData::boundaryconditions(int index) const {
  // @@protoc_insertion_point(field_get:BoundaryConditionsListData.BoundaryConditions)
  return boundaryconditions_.Get(index);
}
inline ::BoundaryConditionsData* BoundaryConditionsListData::add_boundaryconditions() {
  // @@protoc_insertion_point(field_add:BoundaryConditionsListData.BoundaryConditions)
  return boundaryconditions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BoundaryConditionsData >&
BoundaryConditionsListData::boundaryconditions() const {
  // @@protoc_insertion_point(field_list:BoundaryConditionsListData.BoundaryConditions)
  return boundaryconditions_;
}

// -------------------------------------------------------------------

// MarchData

// double Duration_s = 1;
inline void MarchData::clear_duration_s() {
  duration_s_ = 0;
}
inline double MarchData::duration_s() const {
  // @@protoc_insertion_point(field_get:MarchData.Duration_s)
  return duration_s_;
}
inline void MarchData::set_duration_s(double value) {
  
  duration_s_ = value;
  // @@protoc_insertion_point(field_set:MarchData.Duration_s)
}

// -------------------------------------------------------------------

// StopData

// -------------------------------------------------------------------

// ModelInterchangeData

// .BoundaryConditionsListData BoundaryExchangeList = 1;
inline bool ModelInterchangeData::has_boundaryexchangelist() const {
  return Command_case() == kBoundaryExchangeList;
}
inline void ModelInterchangeData::set_has_boundaryexchangelist() {
  _oneof_case_[0] = kBoundaryExchangeList;
}
inline void ModelInterchangeData::clear_boundaryexchangelist() {
  if (has_boundaryexchangelist()) {
    delete Command_.boundaryexchangelist_;
    clear_has_Command();
  }
}
inline ::BoundaryConditionsListData* ModelInterchangeData::release_boundaryexchangelist() {
  // @@protoc_insertion_point(field_release:ModelInterchangeData.BoundaryExchangeList)
  if (has_boundaryexchangelist()) {
    clear_has_Command();
      ::BoundaryConditionsListData* temp = Command_.boundaryexchangelist_;
    Command_.boundaryexchangelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::BoundaryConditionsListData& ModelInterchangeData::boundaryexchangelist() const {
  // @@protoc_insertion_point(field_get:ModelInterchangeData.BoundaryExchangeList)
  return has_boundaryexchangelist()
      ? *Command_.boundaryexchangelist_
      : *reinterpret_cast< ::BoundaryConditionsListData*>(&::_BoundaryConditionsListData_default_instance_);
}
inline ::BoundaryConditionsListData* ModelInterchangeData::mutable_boundaryexchangelist() {
  if (!has_boundaryexchangelist()) {
    clear_Command();
    set_has_boundaryexchangelist();
    Command_.boundaryexchangelist_ = CreateMaybeMessage< ::BoundaryConditionsListData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ModelInterchangeData.BoundaryExchangeList)
  return Command_.boundaryexchangelist_;
}

// .MarchData March = 2;
inline bool ModelInterchangeData::has_march() const {
  return Command_case() == kMarch;
}
inline void ModelInterchangeData::set_has_march() {
  _oneof_case_[0] = kMarch;
}
inline void ModelInterchangeData::clear_march() {
  if (has_march()) {
    delete Command_.march_;
    clear_has_Command();
  }
}
inline ::MarchData* ModelInterchangeData::release_march() {
  // @@protoc_insertion_point(field_release:ModelInterchangeData.March)
  if (has_march()) {
    clear_has_Command();
      ::MarchData* temp = Command_.march_;
    Command_.march_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MarchData& ModelInterchangeData::march() const {
  // @@protoc_insertion_point(field_get:ModelInterchangeData.March)
  return has_march()
      ? *Command_.march_
      : *reinterpret_cast< ::MarchData*>(&::_MarchData_default_instance_);
}
inline ::MarchData* ModelInterchangeData::mutable_march() {
  if (!has_march()) {
    clear_Command();
    set_has_march();
    Command_.march_ = CreateMaybeMessage< ::MarchData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ModelInterchangeData.March)
  return Command_.march_;
}

// .StopData Stop = 3;
inline bool ModelInterchangeData::has_stop() const {
  return Command_case() == kStop;
}
inline void ModelInterchangeData::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void ModelInterchangeData::clear_stop() {
  if (has_stop()) {
    delete Command_.stop_;
    clear_has_Command();
  }
}
inline ::StopData* ModelInterchangeData::release_stop() {
  // @@protoc_insertion_point(field_release:ModelInterchangeData.Stop)
  if (has_stop()) {
    clear_has_Command();
      ::StopData* temp = Command_.stop_;
    Command_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StopData& ModelInterchangeData::stop() const {
  // @@protoc_insertion_point(field_get:ModelInterchangeData.Stop)
  return has_stop()
      ? *Command_.stop_
      : *reinterpret_cast< ::StopData*>(&::_StopData_default_instance_);
}
inline ::StopData* ModelInterchangeData::mutable_stop() {
  if (!has_stop()) {
    clear_Command();
    set_has_stop();
    Command_.stop_ = CreateMaybeMessage< ::StopData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ModelInterchangeData.Stop)
  return Command_.stop_;
}

inline bool ModelInterchangeData::has_Command() const {
  return Command_case() != COMMAND_NOT_SET;
}
inline void ModelInterchangeData::clear_has_Command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline ModelInterchangeData::CommandCase ModelInterchangeData::Command_case() const {
  return ModelInterchangeData::CommandCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ePropertyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ePropertyType>() {
  return ::ePropertyType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ComputationalLifeProtocol_2eproto
